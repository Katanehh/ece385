// This module determines the logic for the game wherein keyboard input must be synced with the timings of the map
// Input will be the keyboard inputs, Position of the ball (X-coordinate), and clock
// Output will be whether or not the user hits accurately 'accurate'

module  game_logic ( input logic Reset, frame_clk,
		     input logic [7:0] keycode, [9:0] BallX
                     output logic accurate );
    
    logic [9:0] Ball_X_Motion, Ball_Y_Motion;
	 
    parameter [9:0] Ball_Target=50;  // Target Circle
    parameter [9:0] Ball_Y_Center=240;  // Center position on the Y axis
    parameter [9:0] Ball_X_Min=0;       // Leftmost point on the X axis
    parameter [9:0] Ball_X_Max=639;     // Rightmost point on the X axis
   
    always_ff @ (posedge frame_clk or posedge Reset) //make sure the frame clock is instantiated correctly
    begin: Move_Ball
        if (Reset)  // asynchronous Reset
        begin 
            		Ball_Y_Motion <= 10'd0; //Ball_Y_Step;
			Ball_X_Motion <= 10'd1; //Ball_X_Step;
			BallY <= Ball_Y_Center;
			BallX <= Ball_X_Center;
        end
           
        else 
        begin 
				 if ( (BallY + BallS) >= Ball_Y_Max )  // Ball is at the bottom edge, BOUNCE!
					  Ball_Y_Motion <= (~ (Ball_Y_Step) + 1'b1);  // 2's complement.
					  
				 else if ( (BallY - BallS) <= Ball_Y_Min )  // Ball is at the top edge, BOUNCE!
					  Ball_Y_Motion <= Ball_Y_Step;
					  
				  else if ( (BallX + BallS) >= Ball_X_Max )  // Ball is at the Right edge, BOUNCE!
					  Ball_X_Motion <= (~ (Ball_X_Step) + 1'b1);  // 2's complement.
					  
				 else if ( (BallX - BallS) <= Ball_X_Min )  // Ball is at the Left edge, BOUNCE!
					  Ball_X_Motion <= Ball_X_Step;
					  
				 else 
					  Ball_Y_Motion <= Ball_Y_Motion;  // Ball is somewhere in the middle, don't bounce, just keep moving
					  
				 //modify to control ball motion with the keycode
				unique case (keycode)
					8'h04 : begin
                          if ( (BallX - BallS) <= Ball_X_Min )  // Ball is at the Left edge, BOUNCE!
					           begin
					               Ball_X_Motion <= Ball_X_Step;
					               BallX <= BallX + 2'b11;
					           end 
					       else
                                begin
								Ball_X_Motion <= -1;//A
								Ball_Y_Motion<= 0;
							    end
						   end
					        
					8'h07 : begin
						  if ( (BallX + BallS) >= Ball_X_Max )  // Ball is at the Right edge, BOUNCE!
					           begin    
					              Ball_X_Motion <= (~ (Ball_X_Step) + 1'b1);  // 2's complement.
					              BallX <= BallX - 2'b11;
							   end
						  else	
							   begin	
					               Ball_X_Motion <= 1;//D
							       Ball_Y_Motion <= 0;
							   end
						end

							  
					8'h16 : begin
                         if ((BallY + BallS) >= Ball_Y_Max )  // Ball is at the bottom edge, BOUNCE!
                             begin
					         Ball_Y_Motion <= (~ (Ball_Y_Step) + 1'b1);  // 2's complement.
					         BallY <= BallY - 2'b11	;				        
					         end
					     else
					         begin
					        Ball_Y_Motion <= 1;//S
							  Ball_X_Motion <= 0;
							 end
						end
							  
					8'h1A : begin
					   if ( (BallY - BallS) <= Ball_Y_Min )  // Ball is at the top edge, BOUNCE!
					       begin
					           Ball_Y_Motion <= Ball_Y_Step;
					           BallY <= BallY + 2'b11;
					       end
					   else
					       begin
					        Ball_Y_Motion <= -1;//W
							  Ball_X_Motion <= 0;
							 end
						end	  
					default: ;
					        /*begin 
					         Ball_Y_Motion <= Ball_Y_Motion;  // Ball is somewhere in the middle, don't bounce, just keep moving
					         Ball_X_Motion <= Ball_X_Motion;
					        end*/
			   endcase
				 
				 BallY <= (BallY + Ball_Y_Motion);
				 BallX <= (BallX + Ball_X_Motion);
			
		end  
    end
      
endmodule
