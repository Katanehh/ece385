// This module will control the way the cursor moves (BallX, BallY)
// The output of this module will be utilized in Color Mapper with data from VGA Controller
// This module determines the next clock cycle position of the cursor, whether it moves or stays in the same position

module  cursor ( 
input logic Reset, frame_clk,
input logic [7:0] mouse_data, // Mouse Displacement Input
output logic [9:0]  BallX, BallY, BallS
);
    
    logic [9:0] Ball_X_Position, Ball_Y_Position; // Position of the cursor
	 
    parameter [9:0] Ball_X_Center=320;  // Center position on the X axis
    parameter [9:0] Ball_Y_Center=240;  // Center position on the Y axis
    parameter [9:0] Ball_X_Min=0;       // Leftmost point on the X axis
    parameter [9:0] Ball_X_Max=639;     // Rightmost point on the X axis
    parameter [9:0] Ball_Y_Min=0;       // Topmost point on the Y axis
    parameter [9:0] Ball_Y_Max=479;     // Bottommost point on the Y axis

    assign BallS = 4;  // default ball size (4 temporarily for testing)
   
    always_ff @ (posedge frame_clk or posedge Reset) //make sure the frame clock is instantiated correctly
    begin
        if (Reset)  // asynchronous Reset
        begin 
           	        Ball_Y_Position <= 10'd0; 
      			Ball_X_Position <= 10'd0; 
      			BallY <= Ball_Y_Center; // Sets the cursor in the center of the screen when reset
      			BallX <= Ball_X_Center;
        end
           
        else // Ensure the Cursor doesn't leave the screen (only half the cursor can be beyond the border)
        begin 
				 if ( (BallY + BallS) >= Ball_Y_Max )  // Ball is at the bottom edge, Stuck at the Border!
					  Ball_Y_Position <= Ball_Y_Max - BallS;  // Ball will not go beyond the edge. Only half the Ball will go over
					  
				 else if ( (BallY - BallS) <= Ball_Y_Min )  // Ball is at the top edge, Stuck at the Border!
					  Ball_Y_Position <= Ball_Y_Min + BallS;  // Ball will not go beyond the edge. Only half the Ball will go over
					  
				 else if ( (BallX + BallS) >= Ball_X_Max )  // Ball is at the Right edge, Stuck at the Border!
					  Ball_X_Position <= Ball_X_Max - BallS;  // Ball will not go beyond the edge. Only half the Ball will go over
					  
				 else if ( (BallX - BallS) <= Ball_X_Min )  // Ball is at the Left edge, Stuck at the Border!
					  Ball_X_Position <= Ball_X_Min + BallS;  // Ball will not go beyond the edge. Only half the Ball will go over
					  
				 else 
					  Ball_Y_Position <= Ball_Y_Position;  // Ball is somewhere in the middle, just keep moving
					  Ball_X_Position <= Ball_X_Position;
	 
				 unique case (keycode)
				 8'hFF : begin	// -1 displacement in x direction (left)
						if (BallX - BallS <= Ball_X_Min)
							begin
								Ball_X_Position <= Ball_X_Min + BallS;
							end
						else
							begin
								Ball_X_Position <= Ball_X_Position - 1; // -1 displacement to position

								8'hFE : begin	// -1 displacement in y direction (up) // THE HEX IS WRONG, JUST TEMPORARY
									if (BallY - BallS <= Ball_Y_Min)
									begin
										Ball_Y_Position <= Ball_Y_Min + BallS;
									end
									else
									begin
										Ball_Y_Position <= Ball_Y_Position - 1; // -1 displacement to position
									end
									end
					
							 	8'h02 : begin	// +1 displacement in y direction (down) // THE HEX IS WRONG, JUST TEMPORARY
									if (BallY + BallS >= Ball_Y_Max)
									begin
										Ball_Y_Position <= Ball_Y_Max - BallS;
									end
									else
									begin
										Ball_Y_Position <= Ball_Y_Position + 1; // +1 displacement to position
									end
									end
							end
					  end

				  8'h01 : begin	// +1 displacement in x direction (right)
						if (BallX + BallS >= Ball_X_Max)
							begin
								Ball_X_Position <= Ball_X_Max - BallS;
							end
						else
							begin
								Ball_X_Position <= Ball_X_Position + 1; // +1 displacement to position
							end
					   end
						
				  8'hFE : begin	// -1 displacement in y direction (up) // THE HEX IS WRONG, JUST TEMPORARY
						if (BallY - BallS <= Ball_Y_Min)
							begin
								Ball_Y_Position <= Ball_Y_Min + BallS;
							end
						else
							begin
								Ball_Y_Position <= Ball_Y_Position - 1; // -1 displacement to position
							end
					   end

				  8'h02 : begin	// +1 displacement in y direction (down) // THE HEX IS WRONG, JUST TEMPORARY
						if (BallY + BallS >= Ball_Y_Max)
							begin
								Ball_Y_Position <= Ball_Y_Max - BallS;
							end
						else
							begin
								Ball_Y_Position <= Ball_Y_Position + 1; // +1 displacement to position
							end
					   end
					
				  default:
				 	 begin
					 Ball_X_Position <= Ball_X_Position;
					 Ball_X_Position <= Ball_X_Position;
					 end
					
				  endcase

		// Assign Final Outputs
		assign BallY <= (Ball_Y_Position);
		assign BallX <= (Ball_X_Position);

	  end				 	 
    end
					
endmodule
